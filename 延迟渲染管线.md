优点：

- 复杂度仅O(n+m)。
- 只渲染可见的像素，节省计算量。
- 用更少的shader
- 对于一些要使用深度纹理、法线纹理等的后处理，这些纹理是“免费”的
- 在大量光源的场景优势尤其明显。

缺点：

- 内存开销较大。
- 读写G-buffer的内存带宽用量是性能瓶颈：每一帧都要生成并传输多个屏幕大小的RenderTexture
- 没法支持透明物体，因此对于透明物体只能再使用前向渲染进行渲染。
- 对多重采样抗锯齿（MultiSampling Anti-Aliasing, MSAA）的支持不友好，主要因为需开启MRT。







a个物体，每个物体有b个mesh，每个mesh最终产生c个片元，灯光共d个

前向渲染：`a*b*c*d`

延迟渲染：先对a*b个mesh进行光栅化，顶点和片元着色器不做处理，只将光栅化后的信息（位置、法线、漫反射纹理颜色、高光反射纹理颜色）保存到GBuffer中（总共GBufferCount个帧缓冲），再对所有GBuffer进行采样并进行光照计算，总消耗为`GBufferCount * ScreenWidth * ScreenHeight * d`
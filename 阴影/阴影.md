Unity使用当今最常见的技术，即阴影贴图shadow mapping。这意味着Unity以某种方式将阴影信息存储在纹理中

### 阴影
- 从摄像机（视角）方向出发，仅记录每个片元的深度值，存储到**与屏幕分辨率匹配**的场景的深度纹理中
- 从光源方向出发，仅将深度存储到灯光的深度纹理中
- 将第一个步骤中得到的裁剪空间下的片元转换到光源空间，其深度值也被转换
- Hidden/Internal-ScreenSpaceShadows.shader逐片元地分别从场景和灯光的深度纹理中采样，比较两者的深度值大小，如果场景深度值>灯光深度值，说明未照亮，否则照亮。并将最终阴影值渲染到屏幕空间阴影贴图（照亮则纹素设置为1，未照亮则为0）
- 采样阴影贴图，并渲染（因为阴影是不透明的，所以会被其他深度值覆盖）
### 接受阴影

### 投射阴影
用一个LightMode为ShadowCaster的Pass来绘制，这个Pass主要做了以下操作
- 应用shadow bias
- 将偏置后的转换到裁剪空间
- 

### Shadow Acne 暗影痤疮

![Pasted image 20201121215342](https://cdn.jsdelivr.net/gh/YuzikiRain/ImageBed@master/img/202109122149968.png)

如上图所示，光线方向与物体表面方向不完全一致。阴影质量很低时，相对于片元来说，阴影就比较大了。因为是从阴影纹理中采样得到的，最小也就是一个纹素大小，此时一部分片元的深度值小于深度缓冲中的深度值，因此不会写入（开启了深度写入），这样这部分阴影就被不透明物体自身（或其他深度值更大的物体）“挡住”了。而另一部分片元的深度值则大于深度缓冲中的深度值，因此会覆盖深度缓冲。这样一来就会表现为物体表面有部分阴影。（即使是与光线方向完全相同的物体表面也会，因为误差等原因)
解决这个问题的方法有阴影偏置shadow bias

![Pasted image 20201121215342](https://cdn.jsdelivr.net/gh/YuzikiRain/ImageBed@master/img/202109122150014.png)


- Depth：减小阴影贴图的整体深度值。增加该值会使得阴影朝着光线方向偏移，如果接收阴影的表面方向与光源方向相同还好，但是如果相差稍大，比如接收阴影的Plane的表面法线方向为(0,0,1)指向上方，而光源方向为(1,-1,0)斜着45度，那么
- Normal：

参考：https://catlikecoding.com/unity/tutorials/rendering/part-7/
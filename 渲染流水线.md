## 流水线

- 准备阶段：设置顶点数据（到缓冲区），设置渲染状态（是否开启ztest，是否开启alpha blend等）

- 几何阶段：顶点着色器->变换模型空间到世界空间->曲面细分着色器->几何着色器（产生更多几何图元primitive，注意不是片元）->变换世界空间到观察空间->背面剔除->观察空间到裁剪空间->裁剪->NDC->裁剪空间到屏幕空间
- 光栅化阶段：对三角形进行光栅化（三角形遍历，三角形遍历）->片元着色器->模板测试->深度测试->透明度混合->输出最终结果

## 背面剔除的时机？

一些说法是NDC之后，或者屏幕映射之后

偶尔不日说“裁剪的实际实现是很复杂的 深挖的话需要查显卡工资的文档才能知道一些细节” ，

我想了下背面剔除的原理是判断三角形环绕顺序，那么至少发生在通过图元产生三角形之后，以及裁剪空间裁剪产生新的图元之后

## 模板测试、深度测试为什么在片元着色器之后？

这么做的确会造成一些最终无法通过测试的片元仍然要经过片元着色器的计算，为了避免这种情况，大部分GPU会采用提前测试的方式先丢弃这些片元，这种方式称为Early-Z

Unity的渲染流水线中的深度测试是发生在片元着色器之前的（来自unity shader入门精要），但是会产生一些冲突。比如我们在片元着色器中进行了透明度测试（alpha test，判断片元的透明度进行discard操作），就会导致GPU无法提前执行各种测试。

现代GPU会判断片元着色器中的操作是否和提前测试发生冲突，如果冲突就会禁用提前测试（测试则发生在片元着色器之后），这一般都会造成性能下降，因为有更多的片元需要处理

参考：[再议移动平台的AlphaTest效率问题 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/33127345)


## 流水线

- 准备阶段：设置顶点数据（到缓冲区），设置渲染状态（是否开启ztest，是否开启alpha blend等）

- 几何阶段：顶点着色器->模型变换：变换模型空间到世界空间->曲面细分着色器->几何着色器（产生更多几何图元primitive，注意不是片元）->观察变换：变换世界空间到观察空间->背面剔除->投影变换：观察空间到裁剪空间->裁剪->**（硬件执行的）透视除法**->NDC->视口变换、屏幕映射：NDC到屏幕空间
- 光栅化阶段：对三角形进行光栅化（三角形遍历，三角形遍历）产生片元，所有变量（interpolator插值器）根据到重心位置的距离进行插值->片元着色器->模板测试->深度测试->透明度混合->输出最终结果

不确定裁剪发生在裁剪空间还是NDC下

### 顶点着色器

顶点着色器返回的变量（如果是结构体，则是所有变量）会在光栅化阶段（根据到重心位置的距离）进行插值

用`SV_POSITION`关键字标记的变量必须存在于返回值内，且还会经过透视除法处理。

### 片元着色器

`positionCS`是已经经过硬件会自动进行透视除法的结果，此时w已经为1

### ComputeScreenPos

虽然的函数名字似乎意味着会直接得到屏幕空间中的位置，但并不是这样的，我们仍需在片元着色器中除以它的w分量来得到真正的视口空间中的位置。那么，为什么Unity不直接在ComputeScreenPos中为我们进行除以w分量的这个步骤呢？为什么还需要我们来进行这个除法？这是因为，如果Unity在顶点着色器中这么做的话，就会**破坏插值**的结果。

我们知道，从顶点着色器到片元着色器的过程实际会有一个插值的过程（如果你忘了的话，可以回顾2.3.6小节）。如果不在顶点着色器中进行这个除法，保留x、y和w分量，那么它们在插值后再进行这个除法，得到的和就是正确的（我们可以认为是除法抵消了插值的影响）。但如果我们直接在顶点着色器中进行这个除法，那么就需要对和直接进行插值，这样得到的插值结果就会不准确。原因是，我们不可以在投影空间中进行插值，因为这并不是一个线性空间，而插值往往是线性的

顶点着色器中将顶点位置变换到齐次裁剪坐标空间下，进行输出（用`SV_POSITION`关键字标记的变量表示顶点着色器的输出）后，再由硬件做透视除法

参考自《Unity shader入门精要》2.3.2章节

## 背面剔除的时机？

一些说法是NDC之后，或者屏幕映射之后

偶尔不日说“裁剪的实际实现是很复杂的 深挖的话需要查显卡工资的文档才能知道一些细节” ，

我想了下背面剔除的原理是判断三角形环绕顺序，那么至少发生在通过图元产生三角形之后，以及裁剪空间裁剪产生新的图元之后

## 模板测试、深度测试为什么在片元着色器之后？

这么做的确会造成一些最终无法通过测试的片元仍然要经过片元着色器的计算，为了避免这种情况，大部分GPU会采用提前测试的方式先丢弃这些片元，这种方式称为Early-Z

Unity的渲染流水线中的深度测试是发生在片元着色器之前的（来自unity shader入门精要），但是会产生一些冲突。比如我们在片元着色器中进行了透明度测试（alpha test，判断片元的透明度进行discard操作），就会导致GPU无法提前执行各种测试。

现代GPU会判断片元着色器中的操作是否和提前测试发生冲突，如果冲突就会禁用提前测试（测试则发生在片元着色器之后），这一般都会造成性能下降，因为有更多的片元需要处理

参考：[再议移动平台的AlphaTest效率问题 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/33127345)


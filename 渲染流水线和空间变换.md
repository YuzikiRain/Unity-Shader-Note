## 流水线

- 准备阶段：设置顶点数据（到缓冲区），设置渲染状态（是否开启ztest，是否开启alpha blend等）

- 几何阶段：顶点着色器->变换模型空间到世界空间->曲面细分着色器->几何着色器（产生更多集合图元primitive，注意不是片元）->变换世界空间到观察空间->背面剔除->观察空间到裁剪空间->裁剪->NDC->裁剪空间到屏幕空间
- 光栅化阶段：对三角形进行光栅化（三角形遍历，三角形遍历）->片元着色器->模板测试->深度测试->透明度混合->输出最终结果

## 裁剪空间和NDC

从观察空间变换到裁剪空间的矩阵被称为裁剪矩阵或投影矩阵，但实际的投影（从三维到二维）发生在NDC坐标空间上，经过透视除法和屏幕映射（视口变换）变换到屏幕空间上

裁剪发生在裁剪空间中，坐标范围在$[-w,w]$之外的会被裁剪。比如观察空间下的位置坐标$(1,2,3,1)$变换到裁剪空间变为$(4,5,6,5)$，此时w分量为5，由于z分量不在$[-5,5]$范围内，因此会被裁剪

对于位置坐标来说

- 透视投影：w并不是固定值，距离摄像机越近（z越小），则w越小。观察空间$(x,y,z,1)$ -> 裁剪空间

    $$\begin{bmatrix}
     x\cdot \cot(fov/2)/aspect\\
     y\cdot \cot(fov/2)\\
     -z(far+near)/(far-near)-2(near\cdot far)(far-near)\\
     -z\end{bmatrix}$$

- 正交投影：w恒为1（因为不受裁剪变换影响）

## 背面剔除发生在观察空间，但顶点着色器返回的已经是经过MVP变换的了？



## 模板测试、深度测试为什么在片元着色器之后？

这么做的确会造成一些最终无法通过测试的片元仍然要经过片元着色器的计算，为了避免这种情况，大部分GPU会采用提前测试的方式先丢弃这些片元，这种方式称为Early-Z

Unity的渲染流水线中的深度测试是发生在片元着色器之前的（来自unity shader入门精要），但是会产生一些冲突。比如我们在片元着色器中进行了透明度测试（alpha test，判断片元的透明度进行discard操作），就会导致GPU无法提前执行各种测试。

现代GPU会判断片元着色器中的操作是否和提前测试发生冲突，如果冲突就会禁用提前测试（测试则发生在片元着色器之后），这一般都会造成性能下降，因为有更多的片元需要处理

[再议移动平台的AlphaTest效率问题 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/33127345)


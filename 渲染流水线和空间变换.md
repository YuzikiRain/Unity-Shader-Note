## 流水线

- 准备阶段：设置顶点数据（到缓冲区），设置渲染状态（是否开启ztest，是否开启alpha blend等）

- 几何阶段：顶点着色器->变换模型空间到世界空间->曲面细分着色器->几何着色器（产生更多几何图元primitive，注意不是片元）->变换世界空间到观察空间->背面剔除->观察空间到裁剪空间->裁剪->NDC->裁剪空间到屏幕空间
- 光栅化阶段：对三角形进行光栅化（三角形遍历，三角形遍历）->片元着色器->模板测试->深度测试->透明度混合->输出最终结果

## 裁剪空间和NDC

从观察空间变换到裁剪空间的矩阵被称为裁剪矩阵或投影矩阵，但实际的投影（从三维到二维）发生在NDC坐标空间上，经过透视除法和屏幕映射（视口变换）变换到屏幕空间上

**裁剪发生在裁剪空间**中，坐标范围在$[-w,w]$之外的会被裁剪。比如观察空间下的位置坐标$(1,2,3,1)$变换到裁剪空间变为$(4,5,6,5)$，此时w分量为5，由于z分量不在$[-5,5]$范围内，因此会被裁剪

对于位置坐标来说

- 透视投影：w并不是固定值，距离摄像机越近（z越小），则w越小。观察空间$(x,y,z,1)$ -> 裁剪空间

    $$\begin{bmatrix}
     x\cdot \cot(fov/2)/aspect\\
     y\cdot \cot(fov/2)\\
     -z(far+near)/(far-near)-2(near\cdot far)(far-near)\\
     -z\end{bmatrix}$$

- 正交投影：w恒为1（因为不受裁剪变换影响）

## 观察空间到裁剪空间的推导

## 坐标系

- OpenGL：除了NDC是左手坐标系，其余都是右手坐标系
- Unity：观察空间和NDC是右手坐标系，其余都是左手坐标系

## 矩阵

在Unity中，对矢量进行矩阵变换通常是把**矩阵放左边,矢量放右边**（将矢量作为列矩阵），称为对矢量左乘一个矩阵
计算顺序为从右到左，即 $CBAv = (C(B(Av)))$，
看起来运算顺序是先**A**然后**B**再**C**，但其实也可以先计算$(CBA)v$。

一般说将矢量看作列矩阵进行矩阵变换时阅读顺序时从右到左，这种说法是不准确的。假设分别有3个变换矩阵$M$（模型空间到世界空间）$V$（世界空间到观察空间）$P$（观察空间到裁剪空间）。那么

- $(P(V(Mv)))$：表示将矢量$v$从模型空间变换到世界空间，再到观察空间，再到裁剪空间，这时候可以在$v$处于不同空间下做不同的处理
- $(PVM)v$：$(PVM)$表示从从模型空间到世界空间再到观察空间再到裁剪空间的一系列变换组合而成的矩阵，不关心中间的过程

Cg对于矩阵类型的变量是按照**行优先**的方式进行填充的，也就是说，对于代码```float3 normal : NORMAL;```中的normal变量来说，用代码```normal = (1.0, 1.0, 1.0);```初始化normal变量，只是按行优先的方式填充数据，这些数据都是**一维**的，并**不代表normal是行矩阵或是列矩阵**。
**在矢量normal与矩阵相乘时，它与矩阵的相乘顺序才决定了函数将其视为行矩阵还是列矩阵来运算（因为矩阵相乘需满足左矩阵列数 = 右矩阵行数）**

```glsl
float3 normal = (1.0, 1.0, 1.0);
// normal会被当做列矩阵（按列展开，3行1列）
float3 columnMatrix = mul((float3x3)unity_WorldToObject, normal)
// normal会被当做行矩阵（按行展开，1行3列）
float3 rowMatrix = mul(normal, (float3x3)unity_WorldToObject)
```

**mul函数的返回值float3仍是一维数据**，根据该变量在函数中的参数顺序（与矩阵相乘的相对顺序）决定将其视为行矩阵或列矩阵

### 法线变换矩阵

如果使用变换顶点位置的M矩阵来变换法线，当M矩阵包含非统一缩放（或其他任何非线性变换）时，

假设在平面XY上，$scale=(1,2)$，那么模型空间下的顶点$A=(1,2)$和顶点$B=(2,1)$以及垂直于AB的法线$N=(1,1)$会变成$A'=(1,4)$和顶点$B'=(2,2)$以及$N'=(1,2)$，然而垂直于A'B'的法线应该为$(2,1)$才对

显然，法线这种表示方向的向量不应该直接像变换顶点一样，应该是由变换后的平面来决定的。比如任取平面上的三个点，组成2个向量，求叉积即可表示平面的法向量即法线。

### 推导

设$M$为模型矩阵，$G$为要求的将法线从本地空间变换到世界空间的**4×4的矩阵（方阵，满足行数和列数相等）**

本地空间：法线$N$、切线$T$，切线$T$上的两点$P_1$和$P_2$

世界空间：分别为$N'$、$T'$、$P_1'$、$P_2'$

由于$N$和$T$垂直，$N'$和$T'$垂直，由点积公式可得

$N \cdot T = 0$

$N' \cdot T' = 0$

将对应向量都扩展为四维向量（对于第四个分量，向量表示位置则设为1，方向则设为0），然后就可以与矩阵一起参与运算。

从第二个式子到第三个式子，是因为点乘可以使用结合律。最后证明可用$M$矩阵将$T$变换到$T'$（但$N$不行）
$$
\begin{align}
T &= P_2 - P_1 \tag{1} \\
MT &= M(P_1-P_2) \tag{2} \\ 
MT &= MP_1-MP_2 \tag{3} \\ 
MT &= P_1'-P_2' \tag{4} \\
MT &= T'
\end{align}
$$
$GN=N'$

$MT=T'$

假设这些一维向量$N$、$T$都是列向量，则$N' \cdot T'$和$N \cdot T$可表示为两个矩阵相乘（左列数等于右行数，要将列矩阵$N'$和$N$进行转置变为行矩阵） ，结果为一个1×1的零矩阵，其唯一元素就是结果0
$$
\begin{align}
N^T T &= N \cdot T \tag{1}\\
N^T T &= 0 \tag{2}\\
\end{align}
$$

$$
\begin{align}
(N')^T T' &= N' \cdot T' \tag{1} \\
(GN)^T MT &= 0 \tag{2} \\ 
N^T G^T MT &= 0 \tag{3} \\ 
\end{align}
$$
假如$G^T M$ 为单位矩阵，即 $G^T M=I$，则上述式子成立。（零矩阵也成立，且零矩阵也是单位矩阵）

根据逆矩阵的性质，（如果G是一个方阵）则有$G G^{-1}=I$，带入上述式子得$G^T=M^{-1}$，$G=(M^{-1})^T$（矩阵的转置的转置等于原矩阵）

最后得到，$G=(M^{-1})^T$

## 背面剔除的时机？

一些说法是NDC之后，或者屏幕映射之后

偶尔不日说“裁剪的实际实现是很复杂的 深挖的话需要查显卡工资的文档才能知道一些细节” ，

我想了下背面剔除的原理是判断三角形环绕顺序，那么至少发生在通过图元产生三角形之后，以及裁剪空间裁剪产生新的图元之后

## 模板测试、深度测试为什么在片元着色器之后？

这么做的确会造成一些最终无法通过测试的片元仍然要经过片元着色器的计算，为了避免这种情况，大部分GPU会采用提前测试的方式先丢弃这些片元，这种方式称为Early-Z

Unity的渲染流水线中的深度测试是发生在片元着色器之前的（来自unity shader入门精要），但是会产生一些冲突。比如我们在片元着色器中进行了透明度测试（alpha test，判断片元的透明度进行discard操作），就会导致GPU无法提前执行各种测试。

现代GPU会判断片元着色器中的操作是否和提前测试发生冲突，如果冲突就会禁用提前测试（测试则发生在片元着色器之后），这一般都会造成性能下降，因为有更多的片元需要处理

参考：[再议移动平台的AlphaTest效率问题 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/33127345)

